#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
LangFlow to LangGraph Converter
-------------------------------

This module contains the core functionality for converting LangFlow JSON exports
into LangGraph Python code.
"""

import json
from typing import Dict, Optional, Tuple


def load_langflow_json(path: str) -> Dict:
    """
    Load a LangFlow JSON file.

    Args:
        path: Path to the JSON file

    Returns:
        Dict containing the parsed JSON data
    """
    with open(path, 'r', encoding='utf-8') as f:
        return json.load(f)


def extract_nodes_and_edges(data: Dict) -> Tuple[Dict, list]:
    """
    Extract nodes and edges from LangFlow JSON data.

    Args:
        data: LangFlow JSON data

    Returns:
        Tuple of (nodes, edges)
    """
    nodes = {node["id"]: node for node in data.get("nodes", [])}
    edges = data.get("edges", [])
    return nodes, edges


def generate_langgraph_code(nodes: Dict, edges: list) -> str:
    """
    Generate LangGraph Python code from nodes and edges.

    Args:
        nodes: Dictionary of node definitions
        edges: List of edge definitions

    Returns:
        String containing the generated Python code
    """
    code_lines = [
        "#!/usr/bin/env python",
        "# -*- coding: utf-8 -*-",
        "",
        "# Generated by langflow2langgraph",
        "",
        "from langgraph.graph import StateGraph",
        "from typing import TypedDict, Annotated",
        "",
        "# Define the state schema",
        "class GraphState(TypedDict):",
        "    input: str",
        "    processed_input: str",
        "    llm_response: str",
        "    output: str",
        "",
        "def create_graph():",
        "    # Initialize the graph with proper state schema",
        "    graph = StateGraph(GraphState)",
        "",
        "    # --- Node Functions ---"
    ]

    node_names = {}

    for node_id, node in nodes.items():
        class_path = node.get("class_path", "")
        label = node.get("data", {}).get("label", f"Node_{node_id}")
        # Clean label for Python function name
        clean_label = ''.join(c if c.isalnum() else '_' for c in label).lower()
        if clean_label[0].isdigit():
            clean_label = 'f_' + clean_label

        node_names[node_id] = label

        if class_path.endswith("PythonFunction") and "code" in node.get("inputs", {}):
            func_code = node["inputs"]["code"]
            # Fix indentation in the function code
            func_lines = func_code.split('\n')
            fixed_func_lines = []
            for line in func_lines:
                if line.startswith('def '):
                    fixed_func_lines.append(f"    {line}")
                else:
                    fixed_func_lines.append(f"        {line}")
            fixed_func_code = '\n'.join(fixed_func_lines)
            code_lines.append(fixed_func_code)
            # Extract function name from the code
            func_name = func_code.split('def ')[1].split('(')[0].strip()
            code_lines.append(f"    graph.add_node(\"{label}\", {func_name})")
        else:
            # Handle different node types appropriately
            if "LLM" in class_path:
                code_lines.append(f"    def {clean_label}(state):")
                code_lines.append(f"        # TODO: implement logic from class {class_path}")
                code_lines.append(f"        # For testing purposes, add a mock LLM response")
                code_lines.append(f"        if \"processed_input\" in state:")
                code_lines.append(f"            state[\"llm_response\"] = f\"Processed: {{state['processed_input']}}\"")
                code_lines.append(f"        return state")
                code_lines.append(f"    graph.add_node(\"{label}\", {clean_label})")
            else:
                # Create a stub function for non-Python nodes
                code_lines.append(f"    def {clean_label}(state):")
                code_lines.append(f"        # TODO: implement logic from class {class_path}")
                code_lines.append(f"        return state")
                code_lines.append(f"    graph.add_node(\"{label}\", {clean_label})")
        code_lines.append("")

    code_lines.append("# --- Edges ---")
    for edge in edges:
        src = node_names.get(edge["source"], edge["source"])
        tgt = node_names.get(edge["target"], edge["target"])
        code_lines.append(f"graph.add_edge(\"{src}\", \"{tgt}\")")

    code_lines.append("\n# --- Entry and Finish ---")
    if node_names:
        # Find entry and exit nodes (this is a simplification)
        # In a real implementation, you might need more sophisticated logic
        first = list(node_names.values())[0]
        last = list(node_names.values())[-1]
        code_lines.append(f"graph.set_entry_point(\"{first}\")")
        code_lines.append(f"graph.set_finish_point(\"{last}\")")

    code_lines.append("\n    # --- Compile and Return ---")
    code_lines.append("    return graph.compile()")
    code_lines.append("")
    code_lines.append("if __name__ == \"__main__\":")
    code_lines.append("    # Example usage")
    code_lines.append("    app = create_graph()")
    code_lines.append("    result = app.invoke({\"input\": \"Your input here\"})")
    code_lines.append("    print(result)")

    return "\n".join(code_lines)


def convert_langflow_to_langgraph(json_path: str, output_path: Optional[str] = None) -> str:
    """
    Convert a LangFlow JSON file to LangGraph Python code.

    Args:
        json_path: Path to the LangFlow JSON file
        output_path: Optional path to save the generated code

    Returns:
        The generated Python code as a string
    """
    data = load_langflow_json(json_path)
    nodes, edges = extract_nodes_and_edges(data)
    langgraph_code = generate_langgraph_code(nodes, edges)

    if output_path:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(langgraph_code)

    return langgraph_code
